<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Brick Breaker Arcade - Game & Guide</title>
    <!-- Load Tailwind CSS for modern, responsive structure and styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for the Game Canvas Area */
        #game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            background-color: #1f2937; /* Dark background */
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        #gameCanvas {
            border: 4px solid #f97316; /* Orange border for arcade feel */
            background: linear-gradient(180deg, #001f3f, #000000);
            border-radius: 8px;
            cursor: pointer;
            touch-action: none; /* Crucial for mobile touch control */
        }

        /* Styling for the interactive buttons and text overlays */
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            text-align: center;
            z-index: 100;
            flex-direction: column;
        }

        .game-button {
            background-color: #10b981;
            color: white;
            padding: 1rem 2rem;
            border-radius: 9999px;
            font-size: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px #047857;
        }

        .game-button:hover {
            background-color: #059669;
            box-shadow: 0 2px #047857;
            transform: translateY(2px);
        }

        /* Footer styling */
        footer a {
            color: #3b82f6;
            transition: color 0.3s;
        }
        footer a:hover {
            color: #1d4ed8;
        }
    </style>
    <!-- AdSense Code Placeholder: Insert the first AdSense code snippet here -->
    <!-- DO NOT delete this placeholder block. Your Publisher ID will go here later. -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXXX"
     crossorigin="anonymous"></script>
    <!-- END AdSense Code Placeholder -->
</head>
<body class="bg-gray-100 font-sans text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        
        <header class="text-center py-6 bg-white shadow-md rounded-lg mb-8">
            <h1 class="text-4xl font-extrabold text-gray-900">Classic Arcade Brick Breaker</h1>
            <p class="mt-2 text-xl text-indigo-600">Your Retro Gaming Destination</p>
        </header>

        <!-- Game Section -->
        <section id="game-section" class="mb-12">
            <h2 class="text-3xl font-bold mb-4 text-center">Play Now!</h2>
            
            <div id="game-area" class="w-full max-w-xl mx-auto aspect-[4/3] relative">
                <canvas id="gameCanvas"></canvas>
                
                <!-- Game Over/Start Overlay -->
                <div id="gameOverlay" class="game-overlay">
                    <h3 id="overlayTitle" class="text-5xl font-extrabold text-white mb-6 drop-shadow-lg">BRICK BREAKER</h3>
                    <button id="startButton" class="game-button">Start Game</button>
                    <p id="controlsText" class="mt-4 text-lg text-gray-300">
                        Controls: Use Left/Right Arrow keys or swipe/drag on the screen.
                    </p>
                </div>
                
                <!-- Score and Status Display (Outside Canvas, Inside Game Area) -->
                <div class="mt-4 w-full flex justify-between px-2 text-white font-mono text-xl">
                    <span id="scoreDisplay">Score: 0</span>
                    <span id="livesDisplay">Lives: 3</span>
                </div>
            </div>
        </section>

        <!-- Written Content Section for AdSense Approval -->
        <section id="content-section" class="bg-white p-6 md:p-10 shadow-lg rounded-lg mb-12">
            <h2 class="text-3xl font-bold text-gray-900 mb-6 border-b pb-2">Brick Breaker: Strategy Guide & Arcade History</h2>
            
            <article class="space-y-6 text-gray-700 leading-relaxed">
                <p>Welcome to the ultimate guide for mastering the classic arcade game, Brick Breaker. This genre, which began with *Breakout* in the 1970s, redefined casual gaming by mixing simple physics with addicting challenge. To gain AdSense approval, a site must demonstrate original, high-quality, and substantial content—something we aim to provide here by diving deep into the game's mechanics and history.</p>

                <h3 class="text-2xl font-semibold text-indigo-700 pt-4">I. The Mechanics of the Ball</h3>
                <p>The ball is the central element of Brick Breaker. Its speed and angle of reflection are critical. Most beginners fail by keeping the paddle directly under the ball, which results in predictable, vertical bounce patterns. The key to high scores is to **control the angle**. Hit the ball with the side edges of the paddle to achieve shallow angles, allowing the ball to travel along the sides and clear isolated bricks that are otherwise hard to reach. Always aim to get the ball *behind* the bricks to clear large patches quickly.</p>

                <h3 class="text-2xl font-semibold text-indigo-700 pt-4">II. Mastering the Paddle and Movement</h3>
                <p>The paddle serves as the player's primary control mechanism. For optimal play, especially on mobile devices where fine movement is difficult, focus on small, precise movements. On desktop, utilizing the arrow keys for short, sharp bursts of speed is more effective than holding the key down. On mobile, quick swipes—not slow drags—are essential to generating the required English on the ball for those game-winning acute angles. Remember that the entire screen is your target area; never get tunnel vision.</p>

                <h3 class="text-2xl font-semibold text-indigo-700 pt-4">III. The History of the Brick Breaking Genre</h3>
                <p>The "paddle-and-ball" genre has a rich heritage. It was famously created at Atari by Steve Wozniak and Steve Jobs, who were tasked with creating a simplified version of *Pong* that could be played solo. This concept evolved into *Breakout* (1976). The core concept—using a moving paddle to deflect a ball into destructible blocks—became an instant classic. Later iterations, such as *Arkanoid* (1986), introduced power-ups, vastly increasing the strategic depth and replayability. This focus on content history and strategy helps establish this domain as an authority site, crucial for demonstrating value to AdSense reviewers.</p>

                <h3 class="text-2xl font-semibold text-indigo-700 pt-4">IV. AdSense Compliance and Content Quality</h3>
                <p>Google AdSense demands sites that offer high-value, original content and excellent user experience. By combining a functional, fun game with detailed, unique articles on the subject, we ensure compliance with their core policies. A clean interface, fast loading times, and a clear site identity are equally important components of a successful application.</p>
            </article>
        </section>

        <!-- AdSense Ad Unit Placeholder -->
        <section class="text-center p-6 bg-yellow-50 border-4 border-yellow-200 rounded-lg mb-12">
            <h3 class="text-xl font-bold text-gray-800 mb-2">AdSense Ad Unit Placeholder</h3>
            <p class="text-gray-600">Once approved, your AdSense ad unit code (the second block of code) will be placed here to display ads above the content.</p>
            
            <!-- Insert your Ad Unit Code here once AdSense is fully approved -->
            <ins class="adsbygoogle"
                 style="display:block; text-align:center;"
                 data-ad-layout="in-article"
                 data-ad-format="fluid"
                 data-ad-client="ca-pub-XXXXXXXXXXXXXXXXX"
                 data-ad-slot="YYYYYYYYYY"></ins>
            <script>
                 (adsbygoogle = window.adsbygoogle || []).push({});
            </script>
        </section>

    </div>

    <footer class="bg-gray-800 text-white p-6 text-center">
        <p class="text-sm">&copy; 2024 Classic Arcade Games. All Rights Reserved.</p>
        <div class="mt-2 space-x-4 text-sm">
            <!-- These links are REQUIRED for AdSense compliance -->
            <a href="#" class="hover:underline">Privacy Policy</a>
            <a href="#" class="hover:underline">Contact Us</a>
            <a href="#" class="hover:underline">Disclaimer</a>
        </div>
    </footer>

    <script>
        // --- GAME LOGIC ---

        // Firebase-related global variables (required but not used in this single-player game)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        // Note: No Firestore or Auth is needed for this simple local game, but variables must be defined.

        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const gameArea = document.getElementById("game-area");
        const gameOverlay = document.getElementById("gameOverlay");
        const startButton = document.getElementById("startButton");
        const overlayTitle = document.getElementById("overlayTitle");
        const scoreDisplay = document.getElementById("scoreDisplay");
        const livesDisplay = document.getElementById("livesDisplay");

        let gameRunning = false;
        let score = 0;
        let lives = 3;

        // Ball properties
        let ball = {
            x: 0, y: 0, radius: 10,
            dx: 3, dy: -3
        };

        // Paddle properties
        let paddle = {
            width: 100, height: 15, x: 0,
            speed: 7, rightPressed: false, leftPressed: false
        };

        // Brick properties
        const brick = {
            rowCount: 5, colCount: 8, width: 60,
            height: 20, padding: 10, offsetTop: 30, offsetLeft: 30,
        };

        let bricks = [];
        
        // Function to initialize the brick grid
        function initBricks() {
            bricks = [];
            for (let c = 0; c < brick.colCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brick.rowCount; r++) {
                    // Start life at 1 (1 hit to destroy)
                    bricks[c][r] = { x: 0, y: 0, status: 1, color: getRandomBrickColor(r) }; 
                }
            }
        }

        function getRandomBrickColor(row) {
            const colors = ['#f87171', '#fb923c', '#fcd34d', '#4ade80', '#60a5fa'];
            // Assign color based on row for a gradient effect
            return colors[row % colors.length];
        }

        // --- Event Listeners for Controls ---
        
        // Desktop Controls
        document.addEventListener("keydown", keyDownHandler, false);
        document.addEventListener("keyup", keyUpHandler, false);

        function keyDownHandler(e) {
            if (!gameRunning) return;
            if (e.key === "Right" || e.key === "ArrowRight") {
                paddle.rightPressed = true;
            } else if (e.key === "Left" || e.key === "ArrowLeft") {
                paddle.leftPressed = true;
            }
        }

        function keyUpHandler(e) {
            if (e.key === "Right" || e.key === "ArrowRight") {
                paddle.rightPressed = false;
            } else if (e.key === "Left" || e.key === "ArrowLeft") {
                paddle.leftPressed = false;
            }
        }

        // Touch/Swipe Controls for Mobile
        let touchStartX = 0;
        let touchCurrentX = 0;

        canvas.addEventListener('touchstart', (e) => {
            if (!gameRunning) return;
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchCurrentX = touchStartX;
        }, false);

        canvas.addEventListener('touchmove', (e) => {
            if (!gameRunning) return;
            e.preventDefault();
            const touchX = e.touches[0].clientX;
            const deltaX = touchX - touchCurrentX;
            touchCurrentX = touchX;

            // Move paddle based on finger drag/swipe delta
            paddle.x += deltaX * 1.5; // Multiplier for faster movement
            
            // Keep paddle within bounds
            if (paddle.x < 0) {
                paddle.x = 0;
            }
            if (paddle.x + paddle.width > canvas.width) {
                paddle.x = canvas.width - paddle.width;
            }
        }, false);

        // --- Game Setup and State Management ---

        function setupGame() {
            // Set canvas size relative to the container size
            const size = Math.min(gameArea.clientWidth, 600); // Max width of 600px, responsive up to container width
            canvas.width = size;
            canvas.height = size * 0.75; // Aspect ratio 4:3 (e.g., 600x450)

            // Center initial positions
            paddle.x = (canvas.width - paddle.width) / 2;
            ball.x = canvas.width / 2;
            ball.y = canvas.height - paddle.height - ball.radius;

            initBricks();
            score = 0;
            lives = 3;
            updateHUD();
            overlayTitle.textContent = "BRICK BREAKER";
            startButton.textContent = "Start Game";
            gameOverlay.style.display = 'flex';
            gameRunning = false;
        }

        startButton.addEventListener('click', startGame);

        function startGame() {
            if (!gameRunning) {
                gameRunning = true;
                gameOverlay.style.display = 'none';
                // Reset game if it was game over
                if (lives <= 0) {
                    setupGame();
                }
                ball.dx = 3;
                ball.dy = -3;
                requestAnimationFrame(draw);
            }
        }

        function gameOver() {
            gameRunning = false;
            overlayTitle.textContent = `GAME OVER! Score: ${score}`;
            startButton.textContent = "Play Again";
            gameOverlay.style.display = 'flex';
        }

        function winGame() {
            gameRunning = false;
            overlayTitle.textContent = `YOU WIN! Final Score: ${score}`;
            startButton.textContent = "Play Again";
            gameOverlay.style.display = 'flex';
        }


        // --- Drawing Functions ---

        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = "#ffffff";
            ctx.fill();
            ctx.closePath();
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddle.x, canvas.height - paddle.height, paddle.width, paddle.height);
            ctx.fillStyle = "#f97316";
            ctx.fill();
            ctx.closePath();
        }

        function drawBricks() {
            for (let c = 0; c < brick.colCount; c++) {
                for (let r = 0; r < brick.rowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        const brickX = (c * (brick.width + brick.padding)) + brick.offsetLeft;
                        const brickY = (r * (brick.height + brick.padding)) + brick.offsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brick.width, brick.height);
                        ctx.fillStyle = bricks[c][r].color;
                        ctx.fill();
                        ctx.strokeStyle = '#374151'; // Dark border
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.closePath();
                    }
                }
            }
        }

        function updateHUD() {
            scoreDisplay.textContent = `Score: ${score}`;
            livesDisplay.textContent = `Lives: ${lives}`;
        }


        // --- Collision and Movement Logic ---

        function collisionDetection() {
            let totalBricks = 0;
            for (let c = 0; c < brick.colCount; c++) {
                for (let r = 0; r < brick.rowCount; r++) {
                    const b = bricks[c][r];
                    if (b.status === 1) {
                        totalBricks++;
                        if (
                            ball.x + ball.radius > b.x &&
                            ball.x - ball.radius < b.x + brick.width &&
                            ball.y + ball.radius > b.y &&
                            ball.y - ball.radius < b.y + brick.height
                        ) {
                            // Collision detected! Reverse the Y direction
                            ball.dy = -ball.dy;
                            b.status = 0; // Destroy the brick
                            score += 100;
                            updateHUD();
                            
                            // Check for win condition
                            if (totalBricks === 1) { // 1 because the current brick hasn't been removed from the count yet
                                winGame();
                            }
                        }
                    }
                }
            }
        }

        function updateBallPosition() {
            // Wall collisions (Left and Right)
            if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
                ball.dx = -ball.dx;
            }
            
            // Wall collisions (Top)
            if (ball.y + ball.dy < ball.radius) {
                ball.dy = -ball.dy;
            } 
            
            // Bottom collision (Game Over/Life Lost)
            else if (ball.y + ball.dy > canvas.height - ball.radius) {
                // Paddle Collision
                if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                    // Reverse Y direction
                    ball.dy = -ball.dy;
                    
                    // Angle calculation for better gameplay (hitting sides changes dx)
                    const hitPoint = ball.x - (paddle.x + paddle.width / 2); // -50 to 50
                    ball.dx = hitPoint * 0.15; // Max angle change 7.5
                    
                } else {
                    // Ball missed the paddle
                    lives--;
                    updateHUD();
                    if (lives <= 0) {
                        gameOver();
                    } else {
                        // Reset ball and paddle position for next life
                        ball.x = canvas.width / 2;
                        ball.y = canvas.height - paddle.height - ball.radius;
                        ball.dx = 3;
                        ball.dy = -3;
                        paddle.x = (canvas.width - paddle.width) / 2;
                    }
                }
            }

            ball.x += ball.dx;
            ball.y += ball.dy;
        }

        function updatePaddlePosition() {
            if (paddle.rightPressed && paddle.x < canvas.width - paddle.width) {
                paddle.x += paddle.speed;
            } else if (paddle.leftPressed && paddle.x > 0) {
                paddle.x -= paddle.speed;
            }
        
